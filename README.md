My approach used random sampling through a heuristic model based on simulated annealing.

Explanation:
The MATLAB script begins by launching a graphical user interface (GUI) through the sudoku_gui() function. When run, this opens a window containing a 9×9 Sudoku grid where each cell is a numeric input field. Users can either manually enter a puzzle, load a default puzzle, or clear the grid using the provided buttons. These buttons - labeled Solve, Given Set, and Clear - sit beneath the grid and are connected to their respective callback functions. Additionally, a status label is positioned under the grid to display progress updates, such as how many steps the solver has taken or whether a solution has been found.
Once the user clicks the Solve button, the program reads all numbers from the grid and determines which cells were pre-filled (the "given" clues) by the user. It does this by marking as “fixed” all nonzero cells, meaning they cannot be modified by the solver. The program then calls the key function simulatedAnnealingSudoku, which attempts to solve the puzzle using a heuristic search process inspired by simulated annealing.
At its core, the simulated annealing solver works by first initializing the Sudoku grid in a way that ensures the 3×3 blocks are valid. This is achieved by the random_fill function, which fills in each block's empty cells randomly using numbers that are not already present within that block. This block-wise filling strategy is crucial because it means the solver only needs to focus on resolving conflicts in the rows and columns, simplifying the overall search space.
Once the initial grid is set up, the solver evaluates the current puzzle’s “cost” using the sudoku_cost function. The cost is calculated by counting, for each row, column, and block, how many unique numbers are missing. Ideally, each should contain the numbers 1 through 9 exactly once; any missing or duplicated numbers increase the cost. The total cost thus reflects how far the current grid is from being a valid Sudoku solution - a cost of zero means the puzzle is fully solved.
The main simulated annealing loop then begins. For each step (up to a maximum of 300,000 iterations), the solver selects a random 3×3 block and identifies two non-fixed cells within it. These two cells are then swapped, generating a new trial grid. The solver recalculates the cost of this new grid and compares it to the previous cost. If the new cost is lower (i.e., the move improves the solution), the swap is accepted. However, even if the new cost is higher (a worse solution), the move may still be accepted with a probability that decreases as the cost difference increases. This acceptance rule, governed by the exponential function exp(-dE/T), is a hallmark of simulated annealing and helps prevent the solver from getting stuck in local minima by occasionally allowing worse solutions to be explored.
As the process continues, the temperature parameter T gradually cools by multiplying it with a small cooling factor at each step. Lower temperatures make the solver more conservative, reducing the likelihood of accepting worse solutions over time. To avoid stagnation, the solver also includes a restart mechanism: if no improvement has been observed after 20,000 steps, it resets by randomly refilling the board (again preserving block uniqueness) and resetting the temperature. Each restart is counted and displayed in the GUI status label, giving the user feedback on how many times the solver had to “shake up” the system.
The solver terminates under two conditions. If a grid with zero cost is found, meaning a valid Sudoku solution has been achieved, the process stops, and the solved grid is returned. Alternatively, if the solver exhausts its maximum allowed steps without finding a solution, it returns the original puzzle state to indicate that solving failed under the current settings. It’s critical to understand that this method does not guarantee a solution. Because simulated annealing is a heuristic (not an exact or complete algorithm), it can fail to solve puzzles - especially if they are under-constrained (multiple solutions), over-constrained (no solution), or if the search space is too complex to explore fully within the allowed steps. In such cases, the solver reports failure, and the GUI notifies the user that no solution was found.
Once the simulated annealing process completes, the GUI updates the displayed Sudoku grid. User-provided inputs are visually distinguished by being set in bold, while the solver-filled cells are displayed in italic. The status label at the bottom of the GUI reports whether the puzzle was successfully solved, how many steps it took, and how many restarts were needed. If no solution is found, a warning is displayed to inform the user that the puzzle could not be completed and may need further input or adjustments.
The supporting functions in the code play vital roles: random_fill guarantees that the search starts from a grid without block conflicts, ensuring the solver focuses only on row and column constraints. The sudoku_cost function provides a continuous way to evaluate solution quality, guiding the annealing process toward valid configurations. Meanwhile, the GUI functions (solveAndDisplay, loadDefaultPuzzle, and clearBoard) manage the user interaction side, allowing for easy puzzle entry, resetting, and real-time progress feedback.
In summary, this MATLAB program combines an interactive GUI with a heuristic solver that uses simulated annealing to navigate the vast solution space of Sudoku puzzles. By leveraging random sampling within blocks, probabilistic acceptance of moves, and strategic restarts, the solver effectively balances exploration and exploitation, working toward a correct solution even in the face of complex or partially filled puzzles.
